# Лабораторные работы по курсу

## Список лабораторных работ:

- [Лабораторная работа 0](https://github.com/NewDawnPRG/1580_9_labs/blob/lab_0/README.md)
- [Лабораторная работа 1](https://github.com/NewDawnPRG/1580_9_labs/blob/lab_1/README.md)
- [Лабораторная работа 2](https://github.com/NewDawnPRG/1580_9_labs/blob/lab_2/README.md)  

1580 Python Rules
====================

> Правила и общий список советов при написании кода на Python для студентов учеников 9 класса лицея 1580.

Содержание
----------

**Work in progress...**


### Пробелы/табы

Не используйте табы для создания отступов в коде. Вместо табов для отступов используется **4 пробела**. Все современные IDE и редакторы кода позволяют настроить клавишу Tab на вставку нужного количества пробелов.

### Общие правила именования

Все объекты языка, которые именуются разработчиком, будь то переменная, функция, тип и т.д., должны иметь осмысленное название, которое должно явно отражать область применения данного объекта.

Не следует применять необоснованные сокращения и ничего не значащие символы (за исключением распротраненных обозначений, например, _i_, _j_, _k_ для итерации внутри цикла, _T_ для обозначения шаблонного типа, _lhs_ и _rhs_ для левого и правого аргумента в подходящих контекстах и т.п.).

Не надо использовать так называемую [венгерскую нотацию](https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%BD%D0%B3%D0%B5%D1%80%D1%81%D0%BA%D0%B0%D1%8F_%D0%BD%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D1%8F).

В названиях должен быть использован грамотный английский язык.

```
c = []  # bad
coordinates = []  # OK

def init_ma(n):  # bad
    pass

def initialize_memory_allocator(identifier):  # OK
    pass
```    

### Семантическое разделение кода на отдельные блоки

В современной разработке программист большую часть времени проводит за чтением кода, а не его написанием. Поэтому важно обеспечить хорошую читаемость кода путем разделения его на небольшие блоки, в каждом из которых описана какая-то логически отделимая часть приложения. Каждый такой блок разделяется отдельной пустой строкой. При этом необходимо находиться в рамках разумных пределов и не делить код слишком сильно.

```
def is_prime(number):
    if number <= 1:
        return False
    for i in range(2, int(number**0.5) + 1):
        if number % i == 0:
            return False
    return True  # bad

def is_prime(number):
    if number <= 1:
        return False

    for i in range(2, int(number**0.5) + 1):
        if number % i == 0:
            return False

    return True  # OK
```

### Функция main

Функция main() должна быть точкой входа программы.

```
def main():
    # основная логика
    pass

if __name__ == "__main__":
    main()
```

Сама функция должна интерпретироваться прежде всего как точка входа, поэтому программная логика внутри main должна быть сведена к минимуму.

### Проверка ошибок

Если функция в ходе своей работы может отработать неправильно (например, идет обработка потенциально некорректного пользовательского ввода), то она должна явно указать это одним из возможных способов сигнализации об ошибке (возвращаемый код, исключение и т.п.).

Если функция может отработать с ошибкой, то вызывающая функция должна предусмотреть дальнейшее поведение тогда, когда есть такая возможность.

### Проверка входных данных

Если функция принимает аргументы, значения которых могут привести к некорректной работе этой функции, то в ней должны проверяться значения этих аргументов на принадлежность области допустимых значений.

```
def divide(dividend, divisor):
    if divisor == 0:
        raise ValueError("Cannot divide by zero")
    return dividend / divisor
```

### Неиспользуемый код

При сдаче лабораторной работы в файлах не должно быть неиспользуемого (закомментированого) кода.

Переменные и константы
----------------------
    
### Одна строка - одна переменная

Для улучшения читаемости на одной строке может быть объявлена только одна переменная.

    a,b,c = 0,0,0 # bad
    
    a = 0 # OK
    b = 0 # OK
    c = 0 # OK
    

### Объявление и инициализация

Инициализируйте переменные при объявлении.

```
value = None  # плохо
value = get_value()  # хорошо
```

Функции
-------

### Правила именования

Функции, как правило, должны семантически отражать какое-то действие (то есть содержать глагол) или отвечать на некоторый вопрос.

```
def directory(name):  # bad
    pass

def create_directory(name):  # OK
    pass

def is_even(number):  # OK
    return number % 2 == 0
```
    

### Размеры

Следует избегать написания слишком больших функций. В идеале, каждая конкретная функция должна выполнять какое-то одно действие, которое выполняется за относительно небольшое количество строк кода (желательно в пределах ~50, но без фанатизма).

### Божественные функции

**Божественная функция** - это такая функция, которая отвечает за много действий разом. Например, принимает пользовательский ввод, обрабатывает его и выводит какой-то результат.

Следует проектировать приложение таким образом, чтобы каждая отдельная функция имела одну конкретную зону ответственности.

Например, функция может отвечать за считывание файла в строку. Другая функция за обработку этих данных. И т.д.

Правильная декомпозиция кода на множество функций улучшает читаемость, поддерживаемость и переиспользуемость кода.    

Операторы
---------


### Бинарные операторы

Между оператором и его операндами должен стоять пробел.

```
result = 5+5  # bad
result = 5 + 5  # OK
```
    
Условия
-------

### Сравнения

Так как каждый тривиальный тип можно неявно привести к _bool_, где 0 - это _false_, а любое другое значение - это _true_, то ко всем таким переменным можно применить оператор логического отрицания (_!_). Это приводит к возможности использования некоторых синтаксических конструкций, которые будут разобраны ниже.

#### С числовыми типами

При сравнении числовых типов следует явно указывать оба операнда, даже если сравнение идет с нулем.

    int a = 0;
    if (a == 5):
        ...
    # OK
    
    if (a == 0):
        ...
    # OK
    
    if (!a):
        ...
    # bad
    

#### С bool

Не следует явно сравнивать переменную с типом _bool_ с булевыми литералами _true_ и _false_. Достаточно просто указывать переменную в условии.

    b = True;
    
    if (b == True):
        ...
    # bad
    
    if (b): # if b is true
        ...
    # OK
    
    if (!b) # if b is false
        ...
    # OK

### Однострочные условия

```
if condition: return value  # bad

if condition:
    return value  # OK
```
    
Циклы
-----

### Использование разных видов циклов

Следует использовать корректные виды циклов в зависимости от стоящей задачи.

Если предполагается какое-то пошаговое изменение с каждой итерацией цикла, то следует предпочитать цикл **for**. Например, если нужно проитерироваться по массиву или обработать какую-то генерируемую последовательность.

Если логика продолжения цикла завязана на статус значения какой-нибудь переменной (своего рода продолжающееся условие), то следует использовать цикл **while**.

Комментарии
-----------

Писать коментарии к коду не нужно. Разрешается и рекомендуется писать алгоритмы.
